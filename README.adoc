= On the Java Record
:author: Pieter van den Hombergh
include::commonhead.adoc[]

== First installment.

This project shows how you can build a typy hierarchy with Java  14+ `record` types.


* The Java record is a final immutable class with
** final means it can't be extended, so a type-hierarchy seems impossible.
* However a record can implement interfaces.
* and interfaces can [black]`extend` other interfaces, even more than classes can.
* and since an [blue]`interface` can have a [black]`static` inner classes

it is quite simple to do, giving all benefits of the record type and a proper hierarchy.

The trick is to give each (relevant) interface an static inner class of the record type, you are done.

.Java type hierarchy
image::docs/images/records.svg[]


.The client program
[source,java]
----
include::typeheirarchy/src/main/java/typeheirarchy/School.java[]
----

.Student Assistant
[source,java]
----
public interface StudentAssistant extends Student, Tutor {

    String course();

    static StudentAssistant of(String name, long digid, String school, String course) {
        return new StudentAssistantRecord( name, digid, school, course );
    }

    static StudentAssistant of(Student aStudent, String course) {
        return new StudentAssistantRecord( aStudent.name(), aStudent.digid(),
                aStudent.school(), course );
    }

    record StudentAssistantRecord(String name, long digid, String school, String course)
       implements StudentAssistant {
          /* look ma, no code */
    }
}
----

.EmeritusTeacher
[source,java]
----
public interface EmeritusTeacher extends Tutor {

    int retirementYear();

    static EmeritusTeacher of(Tutor aTutor, int retirementYear) {
        return new EmeritusTeacherRecord( aTutor, retirementYear );
    }

    record EmeritusTeacherRecord(Tutor tutor, int retirementYear) implements EmeritusTeacher{

        @Override
        public String course() {
            return tutor.course();

        }

        @Override
        public String name() {
            return tutor.name();
        }

        @Override
        public long digid() {
            return tutor.digid();
        }

    }
}
----

When you compare the two types above, you see that the [green]*StudentAssistant* makes short work of the student and unpacks it to make
a complete record.
The [green]**EmeritusTeacher**'s record on the other hand, wants to 'muse' a bit on the better times and unpacks the contained Tutor instance, each time
he is asked about that. Maybe that is fitting in his situation.

'''
